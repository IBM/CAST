# Build Machine Requirements

how in depth to get with installed rpms and where to find pre-reqs like sprectum mpi?

- Red Hat Enterprise Linux 7.5 for ppc64 LE
- cmake 3.7.1
- datacenter-gpu-manager 1.4.0-1
- spectrum mpi 10.2.0
- boost 1.60.0
- java 1.8.0
- doxygen 1.8.10
- mosquitto 1.4.8-1
- fuse 2.9.2-10
- gcc 4.8.5-4
- rpm 4.11.
- rpm-build 4.11.3
- flex 2.5.37-3
- bison 2.7-4
- c-ares 1.10.0-3
- postgresql 9.2.14
- libuuid 2.23.2
- libverbs 1.1.8-8
- librdmacm 1.0.21-1
- openssl 1.0.1e-42

# Source Control

CAST is using the GIT source code repository.  Documentation can be found at https://git-scm.com/doc

There are numerous GIT tools online, some with good graphical representations of the tree, automated diff, etc.  

For the basic commandline utilities:
```
$ git add <filename>
  Adds your changes to your LOCAL repository.  

$ git commit -m "message"
  Commits your changes to your LOCAL repository. 

$ git push
  Pushes any changes in the LOCAL repository to upstream. 

$ git pull
  Pulls any changes from the upstream repository into the LOCAL repository.

$ git status
  Shows which files have either not been commited or pushed upstream.
```

# Code Structure
```
Toplevel components should have the following structure:

toplevel/
    CMakeList.txt
    src/
        CMakeList.txt
        foo.c
    include/
        CMakeList.txt
        foo.h
  
```
The include/ directory is intended for public header files.  Private header files can be stored in the src/ directory (developer preference)

# Build Instructions

what I am using
```
scripts/configure.pl --rpmbuild --parallel --mincmake=3.6
scripts/rebuild package noinstall
```
```
To build the tree:
   % scripts/configure.pl
   % . SETUP.sh
   % build

SETUP.sh is generated by the configure script.  It sets environment variables, include PATH.

% build help
  Shows a list of possible build targets.

% build package
  Builds the RPMs.  For official builds, the work directory must specify the eventual install directory.  

% build bb
  Builds targets for toplevel directory 'bb'.  Only targets that were installed with the doinstall() macro will be built.  

% build burstbuffer
  Builds targets for RPM 'burstbuffer'.  Only targets that were installed with the doinstall() macro will be built.  

If there is a need to rebuild the tree from scratch:
   % rebuild

```
By default, the install directory is bluecoral/work
By default, the build directory is bluecoral/.build

You should not need to access files in the .build directory unless you are generating files.

cmake and Boost libraries need to be installed on the system you're building on:
      If your system is downlevel, run this script:
           scripts/prereq.pl 


create pull request when ready

use of issues

link to user guide

link to binaries in public box

# Maintainers Guide

## Methodology
This repository does not have a traditional release management cycle, but should instead be maintained as as a useful, working, and polished reference at all times. While all work can therefore be focused on the master branch, thequality of this branch should never be compromised.
The remainder of this document details how to merge pull requests to the repositories.
## Merge approval
The project maintainers use LGTM (Looks Good To Me) in comments on the pullrequest to indicate acceptance prior to merging. A change requires LGTMs from two project maintainers. If the code is written by a maintainer, the changeonly requires one additional LGTM.
## Reviewing Pull Requests
We recommend reviewing pull requests directly within GitHub. This allows a public commentary on changes, providing transparency for all users. When providing feedback be civil, courteous, and kind. Disagreement is fine, so longas the discourse is carried out politely. If we see a record of uncivil orabusive comments, we will revoke your commit privileges and invite you to leave the project.
During your review, consider the following points:
### Does the change have positive impact?
Some proposed changes may not represent a positive impact to the project. Ask whether or not the change will make understanding the code easier, or if it could simply be a personal preference on the part of the author.
Pull requests that do not have a clear positive impact should be closed withoutmerging.
### Do the changes make sense?
If you do not understand what the changes are or what they accomplish, ask the author for clarification. Ask the author to add comments and/or clarify testcase names to make the intentions clear.
At times, such clarification will reveal that the author may not be using the code correctly, or is unaware of features that accommodate their needs. If you feel this is the case, work up a code sample that would address the pullrequest for them, and feel free to close the pull request once they confirm.
### Does the change introduce a new feature?
For any given pull request, ask yourself "is this a new feature?" If so, doesthe pull request (or associated issue) contain narrative indicating the need for the feature? If not, ask them to provide that information.
Are new unit tests in place that test all new behaviors introduced? If not, do not merge the feature until they are! Is documentation in place for the newfeature? (See the documentation guidelines). If not do not merge the featureuntil it is! Is the feature necessary for general use cases? Try and keep the scope of any given component narrow. If a proposed feature does not fit that scope, recommend to the user that they maintain the feature on their own, and close the request. You may also recommend that they see if the feature gainstraction among other users, and suggest they re-submit when they can show suchsupport.
